# CS 2240 - Operating Systems

**Date:** 8/25/2025  

---

## Lecture 1: Bruce Bolden – Intro to Operating Systems
**Contact:** JEB 232 · [bruceb@uidaho.edu](mailto:bruceb@uidaho.edu)

### Operating System
- Uses the hardware resources of one or more processors  
- Provides a set of services to system users  
- Manages secondary memory and I/O devices  

### Basic Elements
- **Processor**
- **Main Memory**
  - Volatile
  - Referred to as real memory or primary memory
- **I/O Modules**
  - Secondary memory devices
  - Communications equipment
  - Terminals
- **System Bus**
  - Communication among processors, memory, I/O modules  

### Processor
- **Internal Registers**
  - Memory Address Register (MAR)  
    - Specifies the address for the next read or write  
  - Memory Buffer Register (MBR)  
    - Contains data written into memory or receives data read from memory  
  - I/O Address Register  
  - I/O Buffer Register  

### Processor Registers
- **User-Visible Registers**
  - Enable programmer to minimize main-memory references by optimizing register use
- **Control and Status Registers**
  - Used by processor to control operation
  - Used by privileged OS routines to control program execution  

### User-Visible Registers
- May be referenced by machine language  
- Available to all programs (application + system)  

**Types of Registers:**
- Data  
- Address  
  - Index  
  - Segment pointer  
  - Stack pointer  

**Address Registers:**
- **Index** – Adds an index to a base value to get an address  
- **Segment Pointer** – Memory divided into segments; referenced by segment + offset  
- **Stack Pointer** – Points to top of stack  

**Control and Status Registers:**
- Program Counter (PC) – Address of instruction to be fetched  
- Instruction Register (IR) – Instruction most recently fetched  
- Program Status Word (PSW)  
  - Condition codes  
  - Interrupt enable/disable  
  - Supervisor/user mode  
- Condition Codes or Flags  
  - Bits set by hardware after operations  
  - Examples: Positive, Negative, Zero, Overflow  

### Instruction Execution
- Two steps:  
  1. Fetch instruction from memory  
  2. Execute instruction  

### Instruction Fetch and Execute
- Processor fetches from memory  
- PC holds address of next instruction  
- PC increments after each fetch  

### Instruction Register
- Holds fetched instruction  

**Categories:**
- Processor-memory – Transfer data between CPU and memory  
- Processor-I/O – Transfer data to/from peripheral  
- Data Processing – Arithmetic/logic on data  
- Control – Alters execution sequence  

---

## Lecture 2: Overview

### Instruction Cycle
- START → Fetch Instruction → Execute Instruction → (until HALT)  
- Execution alternates between **Fetch Stage** and **Execute Stage**

### Instruction Fetch & Execute
- Processor fetches from memory  
- PC holds next instruction address  
- PC increments after each fetch  
- Instruction placed in Instruction Register  

**Categories:**
- Processor-memory  
- Processor-I/O  
- Data processing  
- Control  

### Interrupts
- Interrupts normal sequencing  
- Needed because I/O devices are slower than processor  
- Processor must pause to wait  

#### Classes of Interrupts
- **Program** – Errors (overflow, divide by zero, illegal instruction, memory violation)  
- **Timer** – Generated by processor timer for periodic OS tasks  
- **I/O** – Generated by I/O controller (completion or error)  
- **Hardware Failure** – e.g., power failure, memory parity error  

### Interrupt Handling
- **Interrupt Handler** – OS routine to service device  
- **Interrupts** – Suspend execution, transfer control  
- **Interrupt Cycle**  
  - Check for interrupts  
  - If none → fetch next instruction  
  - If pending → suspend program, run handler  

**Diagrams:**  
- ![interrupt](imgs/image-1.png)  
- ![interrupt cycle](imgs/image.png)  
- ![simple_interrupt](imgs/simplintprocess.png)  
- ![chgmemreg](imgs/chgmemreg.png)  
- ![seqintproc](imgs/seqintproc.png)  
- ![multint1](imgs/multint1.png)  
- ![multint2](imgs/multint2.png)  

**Discussion:**  
What issues might arise when testing or verifying correctness of user-defined interrupts?  

---

### Multiprogramming
- Processor executes multiple programs  
- Execution order depends on priority and I/O waiting  
- After interrupt handling, may not resume same program  

---

### Memory Hierarchy
- **Trade-offs:** Faster = more expensive, Slower = cheaper  
- ![mempyrm](imgs/mempyrm.png)

**Hierarchy Trends:**
- Down the hierarchy:  
  - ↓ Cost per bit  
  - ↑ Capacity  
  - ↑ Access time  
  - ↓ Frequency of processor access  

**Details:**
- **Secondary Memory** – Nonvolatile, auxiliary, stores programs/data  
- **Disk Cache**  
  - Main memory buffer for disk  
  - Clustered writes  
  - Faster re-access from cache vs disk  
- **Cache Memory**  
  - Hidden from user/OS  
  - Matches faster CPU speed  
  - Exploits locality  
  - ![cachemem](imgs/cachemem.png)  
  - Processor checks cache first, otherwise fetches from main memory  
  - ![cacheRead](imgs/cacheRead.png)  

**Cache Design:**
- Cache size – small caches still impactful  
- Block size – affects hit rate and eviction probability  
- Mapping function – decides block location in cache  
- Replacement algorithm – e.g., Least Recently Used (LRU)  
- Write policy – when memory write occurs (on update vs on replacement)  

---

### Programmed I/O
- I/O module executes action, not CPU  
- Status register updated  
- No interrupts – CPU must poll status until complete  
- Known as **polling**  
- ![ioprocess](imgs/ioprocess.png)  

---

### Interrupt-Driven I/O
- Processor interrupted when I/O module ready to exchange data  
- Processor saves context of executing program and begins interrupt-handler  
- Eliminates needless waiting  
- Still consumes processor time because **every word read/written passes through processor**  
- ![alt text](imgs/intrdrivio.png)

---

### Direct Memory Access (DMA)
- I/O exchanges occur directly with memory  
- Processor grants I/O module authority to read/write memory directly  
- Relieves processor of data transfer responsibility  

**DMA Transfers:**
- Transfers a block of data directly between memory and device  
- Interrupt sent when transfer completes  
- Processor continues other work during transfer  
- ![alt text](imgs/dnatrans.png)

## Lecture 2 cout.
### Operating System Objectives
- Convenience
  - Makes the computer more convenient to use
- Efficiency
  - Allows computer system resources to be used
in an efficient manner
- Ability to evolve
  - Permit effective development, testing, and
introduction of new system functions
without interfering with service

### Layers of Computer systems

- ![alt text](imgs/compsyslayer.png)

### Services Provided by the **Operating System**
- Program development
- Editors and debuggers
- Program execution
- Access to I/O devices
- Controlled access to files
- Memory management
- System access
- Network support
- Error detection and response
  - Internal and external hardware errors
    - Memory error
    - Device failure
  - Software errors
    - Arithmetic overflow
    - Access forbidden memory locations
  - Operating system cannot grant request of
  application
- Accounting
  - Collect usage statistics  
  - Monitor performance
  - Used to anticipate future enhancements
  - Used for billing purposes
  - Check out the log files of a Unix system
    - Where do you find this information?
### **Operating System**
- Responsible for managing resources
An OS is just a program that is executed
- ![alt text](imgs/compsys.png)
### **Kernel**
- Portion of operating system that is in main
memory
- Contains most frequently used functions
Also called the nucleus

### Time Sharing
- Using multiprogramming to handle multiple interactive job
- Processor's time is shared among multiple users
- Multiple users simultaneously access the system through terminals

## Modern Operating systems

- Features
  - Micro Kernel architecture
    - Assigns only a few essential functions to the kernel
      - address spaces
      - interproccesses
  - Multithreading 
    - Process is divided into threads that can run concurrently
      - Thread
        - dispatchable unit of work
        - executes sequentially and is interruptables
  - Symmetric Multiprocessing 
     - There are multiple processors
     - these share the same main memory
     - all processors cab perform the same functions
  - Distributed OPerating Systems
    - 
    - 
    - 
  - Object-Oriented Design

## Kernel
- memory
- i/o
- hardware abstraction layer
- device drivers
  - low level user request -> i/o calls
- windowing and graphical user interface

## Windows executive 
- i/o manager
- cache manager
- object manager
- plug and play manager
- power manager
- security reference monitor
- virtual memory manager
- process/thread manager
- config manager
- local procedure call (LPC) facility

## User-Mode Processes 
- Special system support processes
  - logon process and the session manager
- service processes
- env subsystems
- user applications

## Client Server model
- Simplifies the Executive
  - Possible to construct a variety of APIs
- Improves reliability
  - each service runs on a separate process with its own partition of memory
  - clients cannot not directly access hardware
- Provides a uniform mechanism for applications to communicate via LPC
- Provides base for distributed computing 

## Threads and SMP
- Operating system routines can run on any available processor
- Different routines can execute simultaneously on different processors 
- Multiple threads of execution within a single process may execute on different processors simultaneously 
- Server processes may use multiple threads 
- Share data and resources between process

## Windows Objects
- Encapsulation 
  - Object consists of one or more data items and one or more procedures 
- Object Class or instance
  - Create 
## UNIX
- Hardware is surrounded by the operating system software
- Operating system is called the system kernel
- Comes with a number of user services and interfaces
  - SHELL
  - Components of the C compiler


## Scheduling and Resource Management 
- Fairness
  - Give equal and fair access to resources 
- Differential responsiveness
  - ...but, OS also needs to discriminate among different classes of jobs
- Efficiency 
  - Maximize throughput, minimize response time, and accommodate as many uses as possible

## System structure
- View the system as a series of levels
- Each level performs a related subset of functions
- Each level relies on the next lower level to perform more primitive functions
- This decomposes a problem into a number of more manageable sub-problems
- a system is just a problem solving system

## Process hardware levels
- Level 1
  - Lowest 
  - electronic circuits
  - objects are registers, memory cells, and logic gates
  - operations are clearing a register or reading a memory location
- Level 2
  - Processor's instruction set 
  - operations such as add, subtract, load, and store
- Level 2
  - Adds the concept of a procedure or subroutines, plus calls/return ops
- Level 4
  - Interrupts
- Level 5
  - Process as a program in execution
  - Suspend and resume processes
- Level 6
  - Secondary storage devices
  - Transfer a block of data
- Level 7
  - Creates Logical

## Requirements of an operating system 
- Interleave the execution of multiple processes to maximize processor utilization while providing reasonable response time
  - Resources made available to multiple applications
  - Processors switch between multiple applications
  - The processor and I/O devices can be used efficiently
- Allocate resources to processes
  - Process is a program in a execution
  - It is also an instance of a program running on a computer
  - it is also the entity that can be assigned to and executed on a processor 
  - it is also a unit of activity characterized by the execution of a sequence of instructions, a current state and an associated set of system instructions
  - Process Elements:
    - identifier
    - state
    - priority
    - program counter
    - memory pointer
    - context data
    - I/O status information
    - Accounting Information
  - Process Control Block 
    - Contains the process elements
    - Create and manage by the operating system
    - Allows support for multiple processes
  - Support interproccesses communication and user creation of processes
  - Trace of Process
    - Sequence of instructions that execute for a process
    - A dispatcher switches the processor from one process to another
## Processes
### Process models
- Two State process model
  - Process may be in one of two states:
    - Running 
    - Not-running
- Not-Running Process in a queue
  - Enters > queue > dispatch > processor > pause > queue > repeat until exit

### Process Creation
- New batch job
  - the operating system is provided with a batch job control stream, usually on a tape or disk. When the os
  is prepared to take on new work, it will read the next sequence of job control commands
- Interactive log on 
  - a user at a terminal logs onto the system
- Created by the OS to provide a service
  - the os can create something to do some work for the program without the user having to wait (printing etc)
- Spawned by existing processes
  - For the purposes of modularity or to exploit parallelism, a user program can dictate the creation of a number of processes

### Process Termination
- Normal completion
- Time limit exceeded
- Memory unavailable 
- Bounds violation
- Protection Error
- Arithmetic Error
- Time overrun
- I/O failure
- Invalid Instruction
- Privileged Instruction
- Data Misuse
- Operator or OS Intervention
- Parent Termination
- Parent request 

### 5 state model
- states
  - running
  - ready
  - blocked
  - new
  - exit

- steps
  - admission into memory (queue)
  - take it off and dispatch to running
    - if it finishes, exit
    - else, timeout back to queue
    - else if event wait, then blocked, if timeout, to queue

### Two queues
- You can use a ready queue and a blocked queue in the 5 state model

### Suspended Processes
- Processor is faster that I/O so all processes could be waiting for I/O
- Swap these processes to disk to free up more memory 
- Blocked state becomes suspend state when swapped to the disk
- Two new states:
  - Blocked/Suspend
  - Ready/Suspend
- suspend models
- ![alt text](imgs/onesuspendqueue.png)
- ![alt text](imgs/twosuspendqueue.png)
- Reasons for process suspension
  - swapping
  - other os reason (if the process is causing issues)
  - interactive user request
  - timing
  - parent process request

### Process Description
- The os controls events with the system, It:
  - schedules and dispatches processes for execution by the processor
  - allocates resources to processor
  - responds to requests by user processes for basic services
- Fundamentally, we can think of the OS as that entity that manages the use of the system resources
- OS Control Structures
  - Information about the current status of each process and resource
  - Tables are constructed for each entity the operating system manages

### OS Tables
  - ![alt text](imgs/ostables.png)
  - Memory Tables
    - Memory tables keep track of:
      - allocation of main memory to processes
      - allocation of secondary memory to processes
      - protection attributes for access to shared memory regions
      - information needed to manage virtual memory
  - I/O Tables
    - used by os to keep track of I/O info
  - File Tables
    - keep track of :
      - existence of files
      - location on secondary memory
      - current status
      - attributes
      - sometimes this information is maintained by a file management system
  - Process Table
    - Manage processes
      - where they are located
      - attributes in the process control block
        - program
        - data
        - stack
### Process Image
- user data
  - the modifiable part of the user space; may include program data, a user stack area, and programs that may be modified
- user program
  - the program to be executed (usually in binary)
- system stack
- process control block

### Process Control Block 
- **PID (process identification)**
  - identifiers
    - numeric ids that may be stored with the process control block
      - id of the process
      - id of the process that created this process (parent)
      - user id
- **Process State information**
  - user-visible registers
    - a user-visible register is one that may be referenced by means of the machine lang that the processor executes while in user mode. Typically, there are from 8-32 of these registers, although some RISC implementations have over 100
  - Control and status registers
    - the are several processor registers that are employed to control the operation of the processor:
      - Program counter
      - condition codes
        - sign, zero, carry, equal, overflow, ect...
      - status info
        - interrupt info, flags, exe mode
  - Stack Pointers 
    - each process has one or more last-in-first-out (LIFO) system stacks associated with it
    - A stack is used to store params and calling addresses for procedure and system calls
    - The stack pointer points to the top of the stack
- **Process Control Info**
  - Scheduling and state info
  - this info is needed by the OS to preform its scheduling function
    - Process State
      - defines the readiness of the process to be scheduled for execution
        - running, ready, waiting, halted
    - Priority
      - one or more fields may be used to describe the scheduling priority of the process
      - example values: default, current, highest-allowable
    - Scheduling-related info
      - this will depend on the scheduling algorithm used. 
      - Examples:
        - amount of time the process has been waiting 
        - amount of time the process executed the last time it was running
    - Event
      - Identity of the event the process is awaiting before it can be resumed
  - Data Structuring 
    - a process may be linked to other processes in a queue, ring, or some other structure
    - the process control block can contain pointers to other processes to support structures like parent child relationships
  - Interprocess Communication
    - various flags, signals, and messages may be associated with communication between two independent processes. Some or all of this info may be maintained in the PCB
  - Process Privileges 
    - Processes can be granted privileges
  - Memory Management
    - pointers to segment/page tables that describe the virtual memory assigned to the process
  - Resources Ownership and Utilization
    - Resources controlled by the process may be indicated, such as opened files. A history of utilization of the processor or other resources may also be included; this information may be needed by the scheduler
    
## Threads
- Threads are contained in processes
- They contain some information
  - an execution state (running, ready, etc.)
  - a saved thread context when not running
    • may view a thread as an independent program counter operating within a process
  - an execution stack
  - some per-thread static storage for local variables
  - access to the memory & resources of its process

### Thread States
- **Spawn**
  - when process is spawned
  - thread may spawn other threads
  - each thread has its own:
    - register context, state space, and place in ready queue
- **Block**
  - when thread waits for event
  - saves user registers, PC and stack pointer
- **Unblock**
  - when blocking event occurs
  - thread is moved to ready queue
- **Finish**
  - register context and stack is deallocated

### Remote Procedure Call
- database 
- money transactions
- apis
- ![RPC](imgs/rpc.png)

### Multithreading with multi processes
- ![multithreading](imgs/multithreading.png)

### ULT over KLT
- Threads switching does not require kernel mode privileges in ult
  - saves two mode switches
- Application specific scheduling
  - applications may prefer their own specific scheduling algorithm
- ULT can run on any OS

### Bad things about ULT
- Many OS sys calls are blocking
  - so if ult exe such call, all threads within its process are blocked
- in a pure ult strategy, a multithreading app cannot take advantage of multiprocessing
  - no concurrency

## Windows
### Windows Processes
- Implemented as objects
- An executable process may contain one or more threads
- Both processes and thread objects have built-in synchronization capabilities

### Windows Process Object
- Object Type
  - PID
  - Security Descriptor
  - Base priority
  - Default processor affinity
- Object Body Attributes
  - Quota limits
  - Execution time
  - I/O counters
  - VM operation counters
  - Exception/debugging ports
  - Exit Status
- Services
  - Create/Open/Query/Terminate

### Windows Thread Object
- Object Type
  - Thread ID
  - Thread Context
  - Dynamic priority
  - Base priority
  - Default processor affinity
- Object Body Attributes
  - thread data 
- Services
  - Create/Open/Query/Terminate/Current Thread
  - other info

### Windows 2000 Thread States
- Runnable
  - Ready
  - Standby
  - Running
- Not Runnable
  - Waiting
  - Transition
  - Terminated

### Solaris
- Process includes the users address space, stack, and PCB
- User-level threads
- Lightweight processes (threads)
- Kernel threads

### Linux Task Data Structure
- State
- Scheduling Information
- Identifiers
- Interprocess communication
- links
- times and timers
- ...other

### Linux States of a Process
- Running 
- Interruptible
- Uniterruptible
- Stopped
- Zombie





 
